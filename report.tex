\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{ulem}
\usepackage[russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

Выполнил студент группы М80-208Б-18 МАИ \textit{Синявский Андрей}.

\subsection*{Условие}
\begin{enumerate}
\item Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа алгоритмом поразрядной сортировки и вывод отсортированной последовательности. 
\item Вариант 5-3.

Поразрядная сортировка.

Тип ключа: MD5-суммы (32-разрядные шестнадцатиричные числа).

Тип значения: числа от 0 до 264 - 1.
\end{enumerate}

\subsection*{Метод решения}

\begin{enumerate}
    \item Данные на вход программе подаются через стандартный поток ввода, так что наиболее лаконичным решением на мой взгляд будет считывание циклом \textbf{while} (пока значение может быть прочитано, продолжать цикл). 
    \begin{lstlisting}[language=C++]
    while(std::cin >> tmp.key && std::cin >> tmp.val)
    \end{lstlisting}
    \item Так как количесво данных заранее не известно, необходимо будет реализовать вектор (по условию задания стандартный вектор из библиотеки STL использовать запрещается).
    \item Ключи будут представляться в виде символьных строк, так что для корректной работы алгоритма сортировки необходимо реализовать функцию, переводящую символ в число (0 в 0, 5 в 5, b в 11 и т. д.).
    \item Алгоритм поразрядной сортировки принимает на вход вектор со входными значениями, и вызывает сортировку подсчётом от последнего до первого элемента ключа.
    \item Сортировка подсчётом принимает тот же вектор входных данных, а также создаёт 2 новых массива: \textbf{res}, в который будет записана отсортированная последовательность, и \textbf{count}, в котором подсчитывается число повторений каждого возможного символа (всего 16, 10 цифр и 6 букв) в сортируемом разряде ключа.
\end{enumerate}

\subsection*{Описание программы}

На каждой непустой строке входного файла располагается пара «ключ-значение»,
поэтому создадим новую структуру \textbf{TData}, в которой будем хранить ключ и значение.

А также мы не знаем количество входных данных, поэтому мы напишем динамический массив - вектор, в который будут помещаться структуры \textbf{TData}.
\begin{table}[!htb]
\begin{tabular}{|m{8cm}|m{8cm}|}
\hline
\multicolumn{2}{|c|}{main.cpp} \\ 
\hline
\cellcolor{gray!25} Тип данных       & \cellcolor{gray!25} Значение\\ 
\hline
struct TData & Структура для хранения пары "ключ-значение" \\ 
\hline
class TVector & Вектор для хранения структур \textbf{TData}\\
\hline
\cellcolor{gray!25} Функция & \cellcolor{gray!25}Значение\\
\hline
TVector() & Конструктор класса \textbf{TVector} \\
\hline
TVector(size_t) & Конструктор класса \textbf{TVector} \\
\hline
$\sim$ TVector() & Деструктор класса \textbf{TVector} \\
\hline
void Add(TData) & Добавить элемент в конец вектора\\
\hline
void CountingSort(size\_t) & Функция сортировки подсчётом\\
\hline
void RadixSort() & Функция порарядной сортировки\\
\hline
int CharToNum(size\_t i, int cInd) & Функция, преобразующая символ в число\\
\hline
int main() & Главная функция, в которой происходит чтение данных, вызов функции сортировки и вывод. \\
\hline
\end{tabular}
\end{table}

\newpage

\subsection*{Дневник отладки}

При создании этой таблицы была использована история посылок.
\begin{table}[!htb]
\begin{tabular}{|m{2cm}|m{3cm}|m{11cm}|}
\hline
Время & Проблема & Описание \\
\hline
2019/10/09 21:47:00 & Ошибка выполнения & Оказалось, что я неверно истолковал задание и сделал ввод данных через входной файл, указываемый в аргументах программы. \\
\hline
2019/10/10 20:59:26	& Превышено реальное время работы & Выделение памяти в векторе происходило при каждом добавлении нового элемента. Решено введением вместимости вектора, которая удваивается при достижении размера вектора предела вместимости. \\
\hline
2019/10/10 21:08:10	 & Превышено реальное время работы & Проблема в неоптимизированном выводе. Использованные методы оптимизации: 1) Опция std::ios\_base::sync\_with\_stdio(false), которая отключает синхронизацию потоков Си и С++, т. е. данные перестат копироваться из буфера в буфер. 2) Опция std::cin.tie(nullptr). Она отделяет изначально связанные потоки cin и cout. При их связи один из потоков сбрасывается перед каждой операцией в другом потоке. \\
\hline

2019/10/11 08:34:07	 & Работает & Далее убирались комментарии и лишние функции, используемые только для отладки программы, вводились незначительные косметические изменения. \\
\hline
\end{tabular}
\end{table}

\subsection*{Тест производительности}

Для генерации тестов использовалась следующая программа:
\begin{lstlisting}[language=C++]
#include <iostream>
#include <fstream>
#include <ctime>
#include <cmath>
#include <cstdlib>

int main(int argc, char *argv[]) {
    std::ofstream file(argv[1]);
    srand(time(0));
    size_t size = atoi(argv[2]);
    char key[33];
    int flag;
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < 32; j++) {
            flag = rand() % 2;
            if (flag) {
                key[j] = (char) (rand() % 10 + 48);
            } else {
                key[j] = (char) (rand() % 6 + 97);
            }
        }
        key[32] = '\0';
        file << key << "\t" << abs(rand()) << "\n";
    }
    return 0;
\end{lstlisting}

\begin{tikzpicture}
	\begin{axis}[ylabel=Время,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
		( 100000, 2.225 )
		( 90000, 1.952 )
		( 80000, 1.765 )
		( 70000, 1.525 )
		( 60000, 1.345 )
		( 50000, 1.101 )
		( 40000, 0.880 )
		( 30000, 0.678  )
		( 20000, 0.451  )
		( 10000, 0.245  )};
	\addplot coordinates {
	( 10000, 0.245)
	( 100000, 2.225 )};
	\end{axis}

\end{tikzpicture}

\subsection*{Недочёты}

Параметр вместимости у вектора, показавшийся мне лишним, как оказаось, в разы ускоряет работу программы.

\subsection*{Выводы}

Данную программу можно использовать для сортировки файлов по их MD5-суммам, где сумма является ключом, а имя файла - значением.

В процессе работы я получил ценный опыт отладки программы и её оптимизации при помощи утилит valgrind и time, углубил и расширил своё понимание принципов языка С++.
\end{document}
